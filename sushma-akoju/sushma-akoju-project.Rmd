---
title: "Spotify Tracks dataset"
author: "Sushma akoju"
date: "9/15/2021"
output: html_document
---

## Dataset Description
#### Spotify Tracks Dataset is about playlist features and how they compare by genre or album/artist ids w.r.t popularity, acoustic ness, danceability, energy, instrumentals, key (musical chords) etc. Since all of us commonly listen to music, we found it interesting to explore various factors and their influence on playlists that become popular.

## About the features
#### It seems that Spotify has defined features based on various audio acoustic features such as Shimmer, pitch, tone, fundamental frequency, etc as well as musical acoustics. https://developer.spotify.com/documentation/web-api/reference/#endpoint-get-audio-features The audio features seem to be based on pitch ranges, harmonics, overtones of musical instruments along with known vocal quality metrics based on features such as jitter, shimmer, pitch, tone etc. Each musical acoustics, as well as voice acoustics, are analyzed based on defined audio signal processing standards.

## Goal
#### We primarily focus and attempt to understand each of the features, their technical definitions cited here https://developer.spotify.com/documentation/web-api/reference/#endpoint-get-audio-features . we would like to see how existing human notions about music fare against what data actually tells us about. For example, it has been widely popular that the C# chord is most popular in western music. We want to find out how the features contribute to popularity. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=30, fig.height=20)
options(scipen=999)

library(tidyverse)
library(readr)
library(dplyr)
library(ggplot2)
library(corrplot)
library(randomForest) # basic implementation
library(purrr)
library(corrr)
library(vtree)
library (reshape)
library(modelsummary)
library(gt)
library(kableExtra)
library(funModeling)
library(rpart)

library("permimp")
library("party", quietly=TRUE)

```


### Get data from url to a Tibble.

```{r }
#rcurl <- getURL("https://www.kaggle.com/zaheenhamidani/ultimate-spotify-tracks-db/download")
data_url <- "https://raw.githubusercontent.com/sushmaakoju/spotify-tracks-data-analysis/main/SpotifyFeatures.csv"
column_names <- c("genre","artist_name","track_name","track_id","popularity","acousticness","danceability","duration_ms","energy","instrumentalness","key","liveness","loudness","mode","speechiness","tempo","time_signature","valence")
spotifydf <- read_csv(data_url, show_col_types=FALSE)
head(spotifydf)
colSums(is.na(spotifydf))
head( spotifydf)
glimpse(spotifydf)
```

## Including Plots
### Some genres are duplicated. (encoding mismatches).

```{r}
na.omit(spotifydf)
genres <- distinct(spotifydf, genre)$genre
genres
spotifydf$genre[spotifydf$genre=="Children's Music"] <- "Childrenâ€™s Music"
spotifydf[!duplicated(spotifydf$track_id),]
#spotifydf[(spotifydf$genre=="Children's Music"),]
genres <- distinct(spotifydf, genre)$genre
```
## Convert character format columns: key and mode to numeric values
```{r}
unique(spotifydf$key)
unique(as.numeric(as.factor(spotifydf$key)))
spotifydf$key <- as.numeric(as.factor(spotifydf$key))

unique(spotifydf$mode)
unique(as.numeric(as.factor(spotifydf$mode)))
spotifydf$mode <- as.numeric(as.factor(spotifydf$mode))

```


### Get all numeric columns from the dataframe.
```{r}
str(spotifydf)
columns <- colnames(spotifydf)
columns
numeric_columns <- unlist(lapply(spotifydf, is.numeric))
numeric_columns
numeric_spotifydf <- spotifydf[,numeric_columns]
colnames(numeric_spotifydf)
```
#### Use Corrr library to plot correlation based on feature groups.
```{r}

corr_df <- correlate(numeric_spotifydf, quiet = TRUE)
corr_df
corr_df %>% 
  select(-term) %>% 
  map_dbl(~ mean(., na.rm = TRUE))
corr_df %>%
  focus(popularity:valence, mirror = TRUE) %>%
  rearrange(absolute = FALSE) %>% 
  shave() %>%
  rplot(colors = c("lightblue", "green"), legend = TRUE) 
corr_df2 <- cor(numeric_spotifydf)
col3 = hcl.colors(10, "YlOrRd", rev = TRUE)
corr1 <- corrplot(corr_df2, col=col3, method = 'number') 
corrplot(corr_df2,  col= c("lightblue", "blue"),method = 'color', order = 'alphabet') 
corrplot(corr_df2,  order = 'hclust', addrect = 2)
corrplot(corr_df2/2, col.lim=c(-0.5, 0.5))
```
### There is a high correlation between energy and loudness features and similarly there is a second highest correlation between valence and danceability where valence is positiveness or negativeness of a track defined by (cheerful vs sad, depressive tune, lyrics)
#### For each feature, plot grouping w.r.t Popularity.
```{r}

genres_df <- spotifydf %>%
   select(popularity, genre)%>%
    count(popularity, genre)
by_genres <- spotifydf %>% group_by(genre, popularity)
by_genres %>% summarise(
  popularity = mean(popularity),
)
by_genre <- by_genres %>% summarise(n = n())
by_genre %>% summarise(n = sum(n)) %>% filter(n>0)
#vtree(genres_df, "genre")
colnames(by_genre)

ggplot(genres_df)+
  geom_point(aes(x = genre, y= n))

genres_df %>% ggplot(aes(x = genre, y= n))+
  geom_line(aes(color = "genre")) 

ggplot(data=by_genre,aes(x = genre, y = n, fill=genre)) +
  geom_bar(stat="identity", width=0.5,  position=position_dodge())+
    #geom_text(aes(label=genre), vjust=1.6, color="white", size=3.5)
coord_flip()+
    #scale_fill_brewer(palette="Pastel1") + theme_minimal()+
    labs(title = "Spotify tracks by Genre in US", y= NULL)
    # geom_errorbar(aes(ymin=n-sd, ymax=n+sd), width=.2,
    #              position=position_dodge(.9))



    #geom_line(aes(color = "genre")) +
  #geom_point(aes(color = "genre")) +
  #geom_line(aes(y = n, color = "n")) +
  # geom_point(aes(y = n, color = "n")) +
  #   scale_y_log10() +
  #   theme(legend.position="bottom",
  #         axis.text.x = element_text(angle = 90)) +

```

```{r}

set.seed(542863)
# cfspotify <- cforest(numeric_columns ~ ., data = numeric_spotifydf,
#                     control = cforest_unbiased(mtry = 2, ntree = 50,
#                                               minbucket = 5, 
#                                               minsplit = 10))

# spotifydf_permimp <- permimp(cfspotify, conditional = TRUE, progressBar = TRUE)


```
```{r}
#plot(spotifydf_permimp, type = "bar")

```
## The above Permutation Importance computations show poor results since values are not normalized and/or adjusting values influences popularity scores very heavily meaning deviation is significant.

```{r}

X <- numeric_spotifydf %>% 
  select(-c(popularity))
y <- numeric_spotifydf %>%
  select(c(popularity))
summary( X)
summary(y)
#xnew <- c(0.45,1.84,2.3)
#points(xnew,df(xnew),col=2)
```

```{r}

genres_df <- spotifydf %>%
  select(-c(artist_name, track_name, track_id, time_signature, key))

```

## Check linear fit between all features vs popularity
## This is multiple regression since we have multiple predictors vs one response variable.
```{r}

lmfit = lm(popularity ~ acousticness + danceability + duration_ms +energy + instrumentalness + liveness + loudness + speechiness + tempo + valence, numeric_spotifydf )
summary(lmfit)
plot(lmfit)
```
# checking coefficients
```{r}
coefficients(lmfit)
```
```{r}

lmfit2 = lm(popularity ~ acousticness + danceability +energy + instrumentalness + liveness + loudness + speechiness + tempo + valence + key+mode+(energy * loudness) + (valence * danceability) , numeric_spotifydf )
summary(lmfit2)
```
```{r}
plot(lmfit2)
```
```{r}
spotify_histograms <- numeric_spotifydf[,-c(4)]
plot_num(spotify_histograms)

ggplot(spotifydf, aes(popularity)) +
  geom_density()
ggplot(spotifydf, aes(energy)) +
  geom_density()
ggplot(spotifydf, aes(danceability)) +
  geom_density()
ggplot(spotifydf, aes(key)) +
  geom_density()
```
```{r}
spotify_summary <- datasummary_skim(numeric_spotifydf)
spotify_summary
```

```{r}
models <- list(
  "OLS"     = lmfit2,
  "GLM" = glm(popularity ~ acousticness + danceability +energy + instrumentalness + liveness + loudness + speechiness + tempo + valence + key+mode+(energy * loudness) + (valence * danceability) , data = numeric_spotifydf , family = gaussian)
)
modelsummary(models,
             fmt = 1,
               estimate  = c(
                "{estimate} ({std.error})",
                "{estimate} [{conf.low}, {conf.high}]"),
               statistic = NULL,
              coef_omit = "Intercept",
             output = "table1.png")


```
```{r}
modelsummary(models,gof_omit = ".*",
               statistic = c("conf.int",
                           "s.e. = {std.error}", 
                           "t = {statistic}",
                           "p = {p.value}"),
             output = "table2.png")
```
## Create train and test sets
```{r}
train = sample(1:nrow(numeric_spotifydf), 300)
rf.spotify = randomForest(popularity~., data = numeric_spotifydf, subset = train)
rf.spotify
```
```{r}
oob.err = double(17)
test.err = double(17)
for(mtry in 1:17){
    fit = randomForest(popularity~., data = numeric_spotifydf, subset=train, mtry=mtry, ntree = 350)
      oob.err[mtry] = fit$mse[350]
      pred = predict(fit, numeric_spotifydf[-train,])
      test.err[mtry] = with(numeric_spotifydf[-train,], mean( (popularity-pred)^2 ))
}



```
## Decision Trees 17*350 trees with MSE for OOB and Test errors
```{r}
matplot(1:mtry, cbind(test.err, oob.err), pch = 23, col = c("red", "blue"), type = "b", ylab="Mean Squared Error", lwd=6)
legend("topright", legend = c("OOB", "Test"), pch = 23, col = c("red", "blue"))

```

```{r}
oob.err 
test.err
```
## Basic Random Forest
```{r}
rf.spotify1 = randomForest(popularity~., data = numeric_spotifydf, subset = train, importance = TRUE)
rf.spotify1
```
## Use Random forest to find Variance based Feature Importances.
```{r}
rf.spotify1$importance
rf.spotify1$importanceSD
```
```{r}
create_rfplot <- function(rf, type){
  
  imp <- importance(rf, type = type, scale = F)
  
  featureImportance <- data.frame(Feature = row.names(imp), Importance = imp[,1])
  
  p <- ggplot(featureImportance, aes(x = reorder(Feature, Importance), y = Importance)) +
       geom_bar(stat = "identity", fill = featureImportance$Importance, width = 0.65) +
       coord_flip() + 
       theme_light(base_size = 25) +
       theme(axis.title.x = element_text(size = 20, color = "black"),
             axis.title.y = element_blank(),
             axis.text.x  = element_text(size = 20, color = "black"),
             axis.text.y  = element_text(size = 20, color = "black")) 
  return(p)
}
create_rfplot(rf.spotify1, type = 2)

```
```{r}
data.frame(Feature = row.names(rf.spotify1$importance), Importance = rf.spotify1$importance[,1])
```
```{r}
rf.spotify2 = randomForest(popularity~., data = numeric_spotifydf, subset = train, replace = FALSE, nodesize = 7, keep.forest = TRUE, keep.inbag = TRUE)
rf.spotify2
permimp <- permimp(rf.spotify2, conditional = TRUE, progressBar = FALSE, do_check=FALSE)
```
```{r}
permimp$values
```

```{r}
ggplot(as.data.frame(permimp$values), aes(x = reorder(names(permimp$values)
, as.numeric(permimp$values)), y = as.numeric(permimp$values))) +
       geom_bar(stat = "identity", fill = as.factor(seq(0,11)), width = 0.65) +
       coord_flip() + 
       theme_light(base_size = 25) +
       theme(axis.title.x = element_text(size = 20, color = "black"),
             axis.title.y = element_blank(),
             axis.text.x  = element_text(size = 20, color = "black"),
             axis.text.y  = element_text(size = 20, color = "black"))+xlab("Features")+ylab("Importance")
```





